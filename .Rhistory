setwd("/home/medafi/git/R-packages/REPPlab/")
library(roxygen2)
roxygenise()
B2P_fixed <- function(x){x %*% solve(crossprod(x)) %*% x}
tmp <- rnorm(40)
B2P_fixed(tmp)
tmp <- rnorm(10)
B2P_fixed(tmp)
eigen(B2P_fixed(tmp))
tmp %*% tmp - tmp
temp2 <- B2P_fixed(tmp)
temp2 %*% temp2 - temp2
round(temp2 %*% temp2 - temp2,3)
B2P_fixed <- function(x){x %*% solve(crossprod(x)) %*% t(x)}
tmp <- rnorm(10)
tmp
B2P_fixed(tmp)
B2P_fixed_t <- function(x){x %*% solve(crossprod(x)) %*% t(x)}
B2P_fixed <- function(x){x %*% solve(crossprod(x)) %*% x}
tmp <- rnorm(10)
B2P_fixed(tmp)
B2P_fixed_t(tmp)
B2P_fixed(tmp) ==
B2P_fixed_t(tmp)
B2P_fixed_t <- function(x){x %*% solve(crossprod(x)) %*% t(x)}
B2P_fixed <- function(x){x %*% solve(crossprod(x)) %*% x}
B2P_fixed2 <- function(x){x %*% tcrossprod(solve(crossprod(x)), x)}
tmp <- rnorm(10)
B2P_fixed2(tmp) == B2P_fixed_t(tmp)
B2P_fixed2 <- function(x){x %*% tcrossprod(solve(crossprod(x)), x)}
B2P_fixed2(tmp)
x <- tmp
crossprod(x)
solve(crossprod(x))
x
tcrossprod(2,runif(4:7))
tcrossprod(2,runif(6))
tcrossprod(0.1234,runif(6))
tcrossprod(0.1234,tmp)
tcrossprod(as.matrix(0.1234),tmp)
x
crossprod(x)
crossprod(x)^-1
B2P_fixed2 <- function(x){tcrossprod(x)/sum(x^2)  }
tmp <- rnorm(10)
B2P_fixed2(tmp)
== B2P_fixed_t(tmp)
B2P_fixed2(tmp) == B2P_fixed_t(tmp)
B2P_fixed_t <- function(x){x %*% solve(crossprod(x)) %*% t(x)}
B2P_fixed <- function(x){x %*% solve(crossprod(x)) %*% x}
B2P_fixed2 <- function(x){tcrossprod(x)/sum(x^2)  }
tmp <- rnorm(10)
B2P_fixed2(tmp) == B2P_fixed_t(tmp)
is.identical(B2P_fixed2(tmp),B2P_fixed_t(tmp))
apropos("ident")
identical(B2P_fixed2(tmp),B2P_fixed_t(tmp))
B2P_fixed2(tmp) - B2P_fixed_t(tmp)
round(B2P_fixed2(tmp) - B2P_fixed_t(tmp),4)
?eigen
library(LDRTools)
tmp <- rnorm(10)
tmp
O2P(tmp)
tmp <- matrix(rnorm(20),ncol=4
)
O2P(tmp)
library(devtools)
require("devtools")
install.packages("devtools")
install.packages("curl")
install.packages("curl")
install.packages("devtools")
install.packages("xml2")
install.packages("devtools")
library(devtools)
install_git("fischuu/REPPlab")
install_git('fischuu/REPPlab')
install_git("REPPlab","fischuu")
install_github('fischuu/REPPlab')
library(LDRTools)
myData <- runif(10)
B2P(myData)
=B2P
?B2P
B2P(as.matrix(myData))
as.matrix(myData)
B2P_fixed(as.matrix(myData))
B2P_fixed(myData)
B2P(as.matrix(myData))
library(LDRTools)
myData <- runif(10)
B2P(myData)
set.seed(45356)
# Load required packages
library(REPPlab)
library(ICS)
library(LDRTools)
library(clue)
library(mclust)
# Function to create the data
createData <- function(n1,n2=NULL,n3=NULL,m1,m2=NULL,m3=NULL,c1,c2=NULL,c3=NULL, mixMatrix=TRUE){
p <- length(m1)
if(is.null(n2)) n2 <- n1
if(is.null(n3)) n3 <- n1
if(is.null(m2)) m2 <- m1
if(is.null(m3)) m3 <- m1
if(is.null(c2)) c2 <- c1
if(is.null(c3)) c3 <- c1
X1 <- rmvnorm(n1, m1, c1)
X2 <- rmvnorm(n2, m2, c2)
X3 <- rmvnorm(n3, m3, c3)
X.comps <- rbind(X1,X2,X3)
if(mixMatrix){
A <- matrix(rnorm(p^2),nrow=p)
#X <- X.comps %*% t(A)
#X <- X.comps %*% Re(eigen(A)$vectors)
X <- X.comps %*% eigen(crossprod(A))$vectors
} else {
X <- X.comps
}
X
}
sim.data <- createData(n1=100,
n2=100,
n3=100,
m1=c(-1,-0.58,rep(0,8)),
m2=c(1,-0.58,rep(0,8)),
m3=c(0,1.15,rep(0,8)),
c1=diag(c(0.1,0.2,rep(1,8))),
#c1=diag(10)
mixMatrix=TRUE)
REPPres.fried <- EPPlab(sim.data, PPalg="Tribe", PPindex="Friedman", n.simu=100, maxiter=200, sphere=TRUE)
REPPres.kmax <- EPPlab(sim.data, PPalg="Tribe", PPindex="KurtosisMax", n.simu=100, maxiter=200, sphere=TRUE)
REPPres.kmin <- EPPlab(sim.data, PPalg="Tribe", PPindex="KurtosisMin", n.simu=100, maxiter=200, sphere=TRUE)
install.packages("mculst")
install.packages(c("mclust","ICS","clue"))
set.seed(45356)
# Load required packages
library(REPPlab)
library(ICS)
library(LDRTools)
library(clue)
library(mclust)
# Function to create the data
createData <- function(n1,n2=NULL,n3=NULL,m1,m2=NULL,m3=NULL,c1,c2=NULL,c3=NULL, mixMatrix=TRUE){
p <- length(m1)
if(is.null(n2)) n2 <- n1
if(is.null(n3)) n3 <- n1
if(is.null(m2)) m2 <- m1
if(is.null(m3)) m3 <- m1
if(is.null(c2)) c2 <- c1
if(is.null(c3)) c3 <- c1
X1 <- rmvnorm(n1, m1, c1)
X2 <- rmvnorm(n2, m2, c2)
X3 <- rmvnorm(n3, m3, c3)
X.comps <- rbind(X1,X2,X3)
if(mixMatrix){
A <- matrix(rnorm(p^2),nrow=p)
#X <- X.comps %*% t(A)
#X <- X.comps %*% Re(eigen(A)$vectors)
X <- X.comps %*% eigen(crossprod(A))$vectors
} else {
X <- X.comps
}
X
}
sim.data <- createData(n1=100,
n2=100,
n3=100,
m1=c(-1,-0.58,rep(0,8)),
m2=c(1,-0.58,rep(0,8)),
m3=c(0,1.15,rep(0,8)),
c1=diag(c(0.1,0.2,rep(1,8))),
#c1=diag(10)
mixMatrix=TRUE)
REPPres.fried <- EPPlab(sim.data, PPalg="Tribe", PPindex="Friedman", n.simu=100, maxiter=200, sphere=TRUE)
REPPres.kmax <- EPPlab(sim.data, PPalg="Tribe", PPindex="KurtosisMax", n.simu=100, maxiter=200, sphere=TRUE)
REPPres.kmin <- EPPlab(sim.data, PPalg="Tribe", PPindex="KurtosisMin", n.simu=100, maxiter=200, sphere=TRUE)
EPPlabAgg(REPPres.fried, "inverse")
x <- REPPres.fried
percentage=0.95
class(x)
list(x)
if(class(x)=="epplab") x <- list(x)
avgMatrix <- matrix(0, nrow=dim(x[[1]]$x)[2], ncol=dim(x[[1]]$x)[2])
length(x)
# Go through each REPPlab result object (using this option, length(x) is probably always equal to 1)
for(i in 1:length(x)){
# Now go through all directions
for(dirRun in 1:dim(x[[i]]$PPdir)[2]){
# Now sum them up
avgMatrix <- avgMatrix + x[[i]]$PPdir[,dirRun] %*% t(x[[i]]$PPdir[,dirRun]   )
}
}
# Divide by the summands to get the average
avgMatrix <- avgMatrix / (dim(x[[i]]$PPdir)[2] * length(x))
# Calculate the eigenelements
eigmave<-eigen(avgMatrix)
lmave<-eigmave$values
umave<-eigmave$vectors
lmave
cumsum(lmave)
avgMatrix
eigmave
(cumsum(lmave)<percentage)
diag(avgMatrix)
sum(diag(avgMatrix))
sum(lmave)
