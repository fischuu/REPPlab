set.seed(45356)
# Load required packages
library(REPPlab)
library(ICS)
library(LDRTools)
library(clue)
library(mclust)
# Function to create the data
createData <- function(n1,n2=NULL,n3=NULL,m1,m2=NULL,m3=NULL,c1,c2=NULL,c3=NULL, mixMatrix=TRUE){
p <- length(m1)
if(is.null(n2)) n2 <- n1
if(is.null(n3)) n3 <- n1
if(is.null(m2)) m2 <- m1
if(is.null(m3)) m3 <- m1
if(is.null(c2)) c2 <- c1
if(is.null(c3)) c3 <- c1
X1 <- rmvnorm(n1, m1, c1)
X2 <- rmvnorm(n2, m2, c2)
X3 <- rmvnorm(n3, m3, c3)
X.comps <- rbind(X1,X2,X3)
if(mixMatrix){
A <- matrix(rnorm(p^2),nrow=p)
#X <- X.comps %*% t(A)
#X <- X.comps %*% Re(eigen(A)$vectors)
X <- X.comps %*% eigen(crossprod(A))$vectors
} else {
X <- X.comps
}
X
}
sim.data <- createData(n1=100,
n2=100,
n3=100,
m1=c(-1,-0.58,rep(0,8)),
m2=c(1,-0.58,rep(0,8)),
m3=c(0,1.15,rep(0,8)),
c1=diag(c(0.1,0.2,rep(1,8))),
#c1=diag(10)
mixMatrix=TRUE)
REPPres.kmax <- EPPlab(sim.data, PPalg="Tribe", PPindex="KurtosisMax", n.simu=100, maxiter=200, sphere=TRUE)
x <- REPPres.kmax
avgMatrix <- matrix(0, nrow=dim(x[[1]]$x)[2], ncol=dim(x[[1]]$x)[2])
# Go through each REPPlab result object (using this option, length(x) is probably always equal to 1)
for(i in 1:length(x)){
# Now go through all directions
for(dirRun in 1:dim(x[[i]]$PPdir)[2]){
# Now sum them up
avgMatrix <- avgMatrix + x[[i]]$PPdir[,dirRun] %*% t(x[[i]]$PPdir[,dirRun]   )
}
if(class(x)=="epplab") x <- list(x)
# Store the the averages, initialize with 0
if(class(x)=="epplab") x <- list(x)
avgMatrix <- matrix(0, nrow=dim(x[[1]]$x)[2], ncol=dim(x[[1]]$x)[2])
# Go through each REPPlab result object (using this option, length(x) is probably always equal to 1)
for(i in 1:length(x)){
# Now go through all directions
for(dirRun in 1:dim(x[[i]]$PPdir)[2]){
# Now sum them up
avgMatrix <- avgMatrix + x[[i]]$PPdir[,dirRun] %*% t(x[[i]]$PPdir[,dirRun]   )
}
}
# Divide by the summands to get the average
avgMatrix <- avgMatrix / (dim(x[[i]]$PPdir)[2] * length(x))
# Calculate the eigenelements
eigmave<-eigen(avgMatrix)
eigmave
lmave<-eigmave$values
umave<-eigmave$vectors
keepmave<-umave[,(cumsum(lmave)<percentage)]
percentage <- 0.95
keepmave<-umave[,(cumsum(lmave)<percentage)]
keepmave
lmave
cumsum(lmave)
which.max(cumsum(lmave)<percentage)
cumsum(lmave)<percentage
cumsum(lmave)
(cumsum((cumsum(lmave)<percentage))
)
which.max(cumsum((cumsum(lmave)<percentage))
)
takeThese <- which.max(cumsum((cumsum(lmave)<percentage)))
takeThese
max(cumsum((cumsum(lmave)<percentage)))
sum((cumsum(lmave)<percentage))
sum((cumsum(lmave)<percentage))
takeThese <- min(sum((cumsum(lmave)<percentage))+1, length(lmave))
takeThese
takeThese <- 1:min(sum((cumsum(lmave)<percentage))+1, length(lmave))
takeThese
set.seed(45356)
# Load required packages
library(REPPlab)
library(ICS)
library(LDRTools)
library(clue)
library(mclust)
# Function to create the data
createData <- function(n1,n2=NULL,n3=NULL,m1,m2=NULL,m3=NULL,c1,c2=NULL,c3=NULL, mixMatrix=TRUE){
p <- length(m1)
if(is.null(n2)) n2 <- n1
if(is.null(n3)) n3 <- n1
if(is.null(m2)) m2 <- m1
if(is.null(m3)) m3 <- m1
if(is.null(c2)) c2 <- c1
if(is.null(c3)) c3 <- c1
X1 <- rmvnorm(n1, m1, c1)
X2 <- rmvnorm(n2, m2, c2)
X3 <- rmvnorm(n3, m3, c3)
X.comps <- rbind(X1,X2,X3)
if(mixMatrix){
A <- matrix(rnorm(p^2),nrow=p)
#X <- X.comps %*% t(A)
#X <- X.comps %*% Re(eigen(A)$vectors)
X <- X.comps %*% eigen(crossprod(A))$vectors
} else {
X <- X.comps
}
X
}
sim.data <- createData(n1=100,
n2=100,
n3=100,
m1=c(-1,-0.58,rep(0,8)),
m2=c(1,-0.58,rep(0,8)),
m3=c(0,1.15,rep(0,8)),
c1=diag(c(0.1,0.2,rep(1,8))),
#c1=diag(10)
mixMatrix=TRUE)
REPPres.fried <- EPPlab(sim.data, PPalg="Tribe", PPindex="Friedman", n.simu=100, maxiter=200, sphere=TRUE)
REPPres.kmax <- EPPlab(sim.data, PPalg="Tribe", PPindex="KurtosisMax", n.simu=100, maxiter=200, sphere=TRUE)
REPPres.kmin <- EPPlab(sim.data, PPalg="Tribe", PPindex="KurtosisMin", n.simu=100, maxiter=200, sphere=TRUE)
EPPlabAgg(REPPres.fried, "inverse")
getwd()
setwd("/home/medafi/git/R-packages/REPPlab")
library(roxygen2)
roxygenise()
